/**
 * This file is generated by Ankit Singh Katiyar
 * Generated On Mar 2, 2014 for the hibernate services of a portal project
 */
package com.ankit.portal.service.domain;

import java.io.Serializable;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Cacheable;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.Lob;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.UniqueConstraint;

import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.Source;
import org.hibernate.annotations.SourceType;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.search.annotations.Analyze;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.Index;
import org.hibernate.search.annotations.Indexed;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.hibernate.search.annotations.Store;

import com.ankit.portal.support.RenderType;
import com.ankit.portal.support.StatusType;

/**
 * {@link Article} represent a Web Article or Web Post
 * 
 * On every change in published version a new saved version is created If any
 * changes made in saved version then no new version will be created only
 * version number will be increased by 0.1
 */
@NamedQueries(value = {
		@NamedQuery(name = "GetArticle", query = "from Article order by lastUpdated desc"),
		@NamedQuery(name = "GetLatestArticles", query = "FROM Article a WHERE (version,uuid) IN (SELECT MAX(version),uuid FROM Article b WHERE a.uuid=b.uuid GROUP BY uuid) order by lastUpdated desc"),
		@NamedQuery(name = "GetLatestArticlesCount", query = "SELECT COUNT(DISTINCT uuid) FROM Article"),
		@NamedQuery(name = "GetTotalArticles", query = "select count(*) from Article"),
		@NamedQuery(name = "GetArticleByUUID", query = "from Article where uuid=? order by lastUpdated desc"),
		@NamedQuery(name = "GetTotalArticlesByUUID", query = "select count(*) from Article where uuid=?"),
		@NamedQuery(name = "GetArticleByTitle", query = "from Article where title= '?'  order by lastUpdated desc"),
		@NamedQuery(name = "GetArticlesByTitle", query = "from Article where title like '%?%' order by lastUpdated desc"),
		@NamedQuery(name = "GetArticleLatestVersionByUUID", query = "from Article where uuid=:uuid and version = (select max(version) from Article where uuid=:uuid ) order by lastUpdated desc"),
		@NamedQuery(name = "GetLatestArticleByUUIDStatus", query = "from Article where uuid=:uuid and status=:status order by version,lastUpdated desc") })
@Indexed
@Entity(name = "Article")
@Table(name = "article", uniqueConstraints = { @UniqueConstraint(columnNames = {
		"title", "version", "uuid_" }) })
@Cacheable(value = true)
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Article implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Field(analyze = Analyze.YES, store = Store.YES, index = Index.YES)
	@Column(name = "article_id")
	private Long articleId;

	@Field(index = Index.YES, analyze = Analyze.YES, store = Store.YES)
	@Column(nullable = false, length = 500, name = "title")
	private String title;

	@Field(index = Index.YES, analyze = Analyze.YES, store = Store.YES)
	@Column(name = "uuid_", nullable = false, updatable = false)
	private String uuid;

	@Field(index = Index.YES, analyze = Analyze.YES, store = Store.YES)
	@Lob
	private String content;

	@Temporal(TemporalType.TIMESTAMP)
	@Column(nullable = false)
	@Source(SourceType.VM)
	@UpdateTimestamp
	@OrderBy(value = "DESC")
	private Date lastUpdated = new Date();

	@Enumerated(EnumType.STRING)
	@Column(nullable = false)
	@Field(index = Index.YES, analyze = Analyze.YES, store = Store.YES)
	private StatusType status;

	@ManyToOne(targetEntity = User.class)
	@JoinColumn(updatable = false)
	private User createdBy;

	@Temporal(TemporalType.TIMESTAMP)
	@Column(nullable = false, updatable = false)
	@Source(SourceType.VM)
	@CreationTimestamp
	private Date createdOn = new Date();

	@Column(nullable = false, name = "version")
	private Double version = 1.0;

	@ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
	@JoinTable(name = "article_referenced_article")
	private Set<Article> references = new HashSet<Article>();

	@ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
	@JoinTable(name = "article_external_references")
	private Set<Reference> externalReferences = new HashSet<Reference>();

	@Column(nullable = false)
	private boolean searchable = true;

	/**
	 * Roles those are allowed to view this article<br>
	 * If not provided consider all
	 */
	@ManyToMany(cascade = CascadeType.REFRESH, fetch = FetchType.LAZY)
	@JoinTable(name = "article_roles", joinColumns = @JoinColumn(name = "article_id"), inverseJoinColumns = @JoinColumn(name = "role_id"))
	private Set<Role> roles = new HashSet<Role>();

	@Column(nullable = false)
	@Enumerated(EnumType.STRING)
	private RenderType renderType = RenderType.NORMAL;

	@IndexedEmbedded(indexNullAs = "", prefix = "tags")
	@ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
	@JoinTable(name = "article_tags", joinColumns = @JoinColumn(name = "article_id"), inverseJoinColumns = @JoinColumn(name = "tag_id"))
	private Set<Tag> tags = new HashSet<Tag>();

	@Column(name = "article_meta", length = 500)
	@Field(analyze = Analyze.YES, store = Store.YES, index = Index.YES)
	@IndexedEmbedded(indexNullAs = "")
	private String meta;

	public Long getArticleId() {
		return articleId;
	}

	public void setArticleId(Long articleId) {
		this.articleId = articleId;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Date getLastUpdated() {
		return lastUpdated;
	}

	public StatusType getStatus() {
		return status;
	}

	public void setStatus(StatusType status) {
		this.status = status;
	}

	public User getCreatedBy() {
		return createdBy;
	}

	public void setCreatedBy(User createdBy) {
		this.createdBy = createdBy;
	}

	public Date getCreatedOn() {
		return createdOn;
	}

	public Double getVersion() {
		return version;
	}

	public void setVersion(Double version) {
		this.version = version;
	}

	public Set<Article> getReferences() {
		return references;
	}

	public void setReferences(Set<Article> references) {
		this.references = references;
	}

	public Set<Reference> getExternalReferences() {
		return externalReferences;
	}

	public void setExternalReferences(Set<Reference> externalReferences) {
		this.externalReferences = externalReferences;
	}

	public Set<Role> getRoles() {
		return roles;
	}

	public void setRoles(Set<Role> roles) {
		this.roles = roles;
	}

	public RenderType getRenderType() {
		return renderType;
	}

	public void setRenderType(RenderType renderType) {
		this.renderType = renderType;
	}

	public Set<Tag> getTags() {
		return tags;
	}

	public void setTags(Set<Tag> tags) {
		this.tags = tags;
	}

	public String getUuid() {
		return uuid;
	}

	public void setUuid(String uuid) {
		this.uuid = uuid;
	}

	public String getMeta() {
		return meta;
	}

	public void setMeta(String meta) {
		this.meta = meta;
	}

	@Override
	public String toString() {
		return "Article [articleId=" + articleId + ", title=" + title
				+ ", meta=" + meta + ", uuid=" + uuid + ", content=" + content
				+ ", lastUpdated=" + lastUpdated + ", status=" + status
				+ ", lastModifiedBy=" + ", createdBy=" + createdBy
				+ ", createdOn=" + createdOn + ", version=" + version
				+ ", renderType=" + renderType + "]";
	}

	public boolean isSearchable() {
		return searchable;
	}

	public void setSearchable(boolean searchable) {
		this.searchable = searchable;
	}
}